" General {{{
set encoding=utf-8              " Encoding
let s:codewidth=80              " Maximum line length (+1)
set timeoutlen=250
set ttimeoutlen=0
set modeline                    " Special comments for file-specific settings
" }}}
" Colors {{{
colorscheme justin              " vim/colors/justin.vim
syntax enable                   " Enable syntax processing
" Background color change at codewidth+1
let &colorcolumn=join(range(s:codewidth+1, 999), ",")
" }}}
" UI Layout {{{
set number                      " Show line numbers
filetype plugin indent on       " Filetype dependent indenting
set formatoptions=              " Clear default format options
set fillchars=stl:\ ,stlnc:\ ,vert:\ ,fold:-    " Fill Characters
"set formatoptions+=ro           " Auto insert comment leader
"set cursorline                  " Enable cursor line highlighting
"set scrolloff=999               " Lock cursor to middle of screen
" }}}
" Spaces & Tabs {{{
set softtabstop=4               " Number of spaces in tab when editing
set shiftwidth=4                " Number of spaces for >>> operations
set expandtab                   " Tabs are spaces
" }}}
" Text Wrapping {{{
" Soft Wrap Options
set wrap
set linebreak
" Hard Wrap Options (can be triggered with gq)
let &textwidth=(s:codewidth-1)  " Set textwidth to codewidth variable
set formatoptions-=t            " Don't auto hard wrap text
set formatoptions+=l            " Don't autowrap existing long lines
set formatoptions+=q            " Allow reformating with gq
set wrapmargin=0                " Don't wrap based on terminal size
" }}}
" Performance {{{
"set lazyredraw
let synmaxcol=(s:codewidth*2)
syntax sync minlines=128
set ttyfast                     " Fast scrolling
set regexpengine=1              " Use older, faster regex engine
let loaded_matchparen = 1       " Disable parenthesis highlighting
" }}}
" Folding {{{
set foldenable                  " Enable folding
set foldlevelstart=10           " Open most folds by default
set foldnestmax=10              " 10 nested fold max
set foldmethod=indent           " Fold based on indent level
" Custom fold text function
function! FoldText()
    let line = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
    let lines_count = v:foldend - v:foldstart + 1
    let lines_count_text = ' (' . printf("%s", lines_count . ' lines') . ')'
    let foldchar = matchstr(&fillchars, 'fold:\zs.')
    let foldtextstart = strpart(repeat(' ', (v:foldlevel-1)*2) . '+' . line, 0, (winwidth(0)*2)/3)
    let foldtextend = lines_count_text
    let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
    return foldtextstart . repeat(foldchar, s:codewidth-1-foldtextlength) . foldtextend . repeat(' ', winwidth(0)-s:codewidth-1)
endfunction
set foldtext=FoldText()
" }}}
" Key Mappings {{{

" Normal Mode -----------------------------------------------------------------
" For yanking line consistency
nnoremap Y y$
" Move vertically by visual line
nnoremap j gj
nnoremap k gk
" Insert lines above and below without exiting normal mode
" <C-j> remapped to <F8> in Xresources (otherwise triggers <NL>)
nnoremap <F8> o<Esc>
nnoremap <C-k> O<Esc>

" Insert Mode -----------------------------------------------------------------
" Move up and down rows without exiting insert mode
" <C-j> remapped to <F8> in Xresources (otherwise triggers <NL>)
inoremap <F8> <Esc>o
inoremap <C-k> <Esc>O
" Move the beginning and ending of a line easily in insert mode
" <C-h> remapped to <F7> in Xresources (otherwise triggers <BS>)
inoremap <F7> <Esc>I
inoremap <C-l> <Esc>A

" Horizontal Lines ------------------------------------------------------------
function! FillLine(char)
    let s:tw = (col('.') == 1) ? 0 : col('.')
    call setline('.', getline('.') . repeat(a:char, s:codewidth - 1 - s:tw))
endfunction
" <C-equal> remapped to <F12> in Xresources
" <C-minus> remapped to <F10> in Xresources
" <C-underscore> remapped to <F9> in Xresources
inoremap <silent> <F12> <Esc>:call FillLine('=')<CR>A
inoremap <silent> <F10> <Esc>:call FillLine('-')<CR>A
inoremap <silent> <F9>  <Esc>:call FillLine('_')<CR>A
inoremap <silent> <F6>  <Esc>:call FillLine('.')<CR>A

" }}}
" Leader Key {{{

" <Space> is Leader Key
map <Space> <Leader>

" Files
nnoremap <Leader>w :w<CR>
nnoremap <Leader>q :q<CR>

" Folding
nnoremap <Leader>a za

" Page Navigation
nnoremap <Leader>z zz
nnoremap <Leader>H Hzz
nnoremap <Leader>L Lzz
nnoremap <Leader>M Mzz

" Text Wrap Formatting
nnoremap <Leader>f vipgq

" Buffers
nnoremap <silent> <Leader>c :enew<CR>
nnoremap <silent> <Leader>x :bw<CR>
nnoremap <silent> <Leader>p :bprevious<CR>
nnoremap <silent> <Leader>n :bnext<CR>
nnoremap <silent> <Leader>b :ls<CR>

" Splits
nnoremap <silent> <Leader>\| :vsplit<CR>
nnoremap <silent> <Leader>- :split<CR>
nnoremap <Leader>h <C-w>h
nnoremap <Leader>j <C-w>j
nnoremap <Leader>k <C-w>k
nnoremap <Leader>l <C-w>l

" Misc
nnoremap <silent> <Leader>/ :CtrlP<CR>
nnoremap <silent> <Leader>t :call NumberToggle()<CR>
nnoremap <silent> <Leader>r :call BrowserReload()<CR>
nnoremap <silent> <Leader>o :call BrowserOpen()<CR>

" }}}
" Statusline {{{
set laststatus=2                "2-line status bar
let g:modename = {
    \ 'n'  : 'NORMAL',
    \ 'no' : 'N-OPERATOR',
    \ 'i'  : 'INSERT',
    \ 'R'  : 'REPLACE',
    \ 'Rv' : 'V-REPLACE',
    \ 'v'  : 'VISUAL',
    \ 'V'  : 'V-LINE',
    \ '^V' : 'V-BLOCK',
    \ 's'  : 'SELECT',
    \ 'S'  : 'S-LINE',
    \ '^S' : 'S-BLOCK',
    \ 'c'  : 'COMMAND',
    \ 'cv' : 'VIM-EX',
    \ 'ce' : 'EX',
    \ 'r'  : 'PROMPT',
    \ 'rm' : 'MORE',
    \ 'r?' : 'CONFIRM',
    \ '!'  : 'SHELL',
    \ 't'  : 'TERMINAL'
    \}
let g:modecolor = {
    \ 'n'  : '2',
    \ 'i'  : '3',
    \ 'v'  : '4'
    \}
function! SetStatusLine(mode)
    set statusline=
    "Set mode color
    exe "set statusline+=%".g:modecolor[a:mode]."*"     
    set statusline+=\                                   "Insert 1 space
    "Print mode name
    exe "set statusline+=".g:modename[a:mode]
    set statusline+=\ 
    set statusline+=%1*\ %<%F\                             "File+path
    set statusline+=%=%{strlen(&ft)?&ft:'none'}\        "Filetype
    set statusline+=%{''.(&fenc!=''?&fenc:&enc).''}\    "Encoding
    "Set mode color
    exe "set statusline+=%".g:modecolor[a:mode]."*"
    set statusline+=\ %03l:%03c\                        "Row and col
endfunction

autocmd InsertEnter * call SetStatusLine(v:insertmode)
autocmd InsertLeave * call SetStatusLine(mode())
autocmd BufEnter    * call SetStatusLine(mode())
" }}}
" Tabline{{{
set hidden                      "Switch between buffers without forcing save
set showtabline=2               "Always show tabline
function! Tabline()
    let s = ''
    for i in range(1, bufnr('$'))
        if bufexists(i)
            let bufname = bufname(i)
            if (bufname != 'ControlP' || bufname != '[Scratch]')
                let bufselected = (i == bufnr('%'))
                let bufmodified = getbufvar(i, "&mod")
                let s .= (bufselected ? '%#TabLineSel#' : '%6*')
                let s .= (bufname != '' ? '  '. fnamemodify(bufname, ':t') .' ': ' [new] ')
                if bufmodified
                    let s .= (bufselected ? '%5*[+] ' : '%7*[+] ')
                else
                    let s .= '    '
                endif
            endif
        endif
    endfor
    let s .= '%#TabLineFill#'
    return s
endfunction
set tabline=%!Tabline()
" }}}
" Plugins {{{

" auto-pairs-gentle
let g:AutoPairsUseInsertedCount = 1

" key bindings for UltiSnipsExpandTrigger
let g:UltiSnipsExpandTrigger = "<Tab>"
" <C-j> remapped to <F8> in Xresources (otherwise triggers <NL>)
let g:UltiSnipsJumpForwardTrigger = "<F8>"
let g:UltiSnipsJumpBackwardTrigger = "<C-k>"
" Snippets directory
let g:UltiSnipsSnippetsDir = $HOME."/.vim/ultisnips"
let g:UltiSnipsSnippetDirectories = [$HOME.'/.vim/ultisnips']

" Nerd Commenter
" Add spaces after comment delimeters by default
let g:NERDSpaceDelims = 1

" }}}
" Custom Functions {{{

" Open File in Browser --------------------------------------------------------
function! BrowserOpen()
    if (&filetype == "html")
        let currWin = system("xdotool getwindowfocus")
        call system("google-chrome " . expand('%:p'))
        call system("xdotool windowactivate " . currWin)
        echom "File opened in Chrome."
    else
        echom "Not an HTML file."
    endif
endfunction

" Refresh Browser -------------------------------------------------------------
" (requires xdotool)
function! BrowserReload()
    let currWin = system("xdotool getwindowfocus")
    call system("xdotool search --onlyvisible --class google-chrome windowfocus key F5")
    call system("xdotool windowactivate " . currWin)
    echom "Chrome refreshed (" . strftime('%H:%M:%S') . ")"
endfunction

" Toggle Relative Numbering ---------------------------------------------------
function! NumberToggle()
    if (&relativenumber == 1)
        set number
        set norelativenumber
    else
        set nonumber
        set relativenumber
    endif
endfunction

" }}}
" Backup {{{
"
set directory^=$HOME/.vimswp//  " Swapfile directory

" }}}
" Modeline {{{
" vim:foldmethod=marker:foldlevel=0
" }}}
